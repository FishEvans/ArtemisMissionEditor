Mission class contains links to the TreeViewEx control. 

All the mission's XML is actually contained in the TreeViewEx control's node list, in the node's tags. 
The TreeViewEx control is available as a property to Mission clas (TreeViewNodes). 
It holds Nodes (one Node = one XML element inside the root mission element). Node's tag is a MissionNode class that contains the XML for the node and stuff.

MissionNodes (when appropriate) contain MissionStatements (conditions and actions). 
Based on those, when a Node which is an Event or Start is selected, another TreeViewEx is populated with nodes.
MissionNode can also be a comment (root-level comment)

MissionStatement class contains everything about one statement (attributes with values etc.)
When you change something in a statement, change does into MissionStatement class, and that's directly MissionNode updated. 
After anything is changed, TreeViewStatements is updated (along with labels).
MissionStatement can also be a comment (event-level comment)

In order to be able to both display and edit a statement, we must parse it and split it into parts. 

For example, we split <create type="anomaly" use_gm_position="" /> into: 
- Create
- anomaly
- at GM position
- with name
- <name>

Now we can edit the value or the name separately, and everything is constructed into a string which is humanly readable: "Create anomaly at GM position with name <name>"


The way this is done:

Each statement is parsed by doing a series of branching decisions:
- first we decide, wether the statement is a condition, action or a comment (assume it's an action)
- next we decide, what kind of action the statement is (assume it's a "create" action)
- next we decide, what kind of create action it is (assume it's a "create anomaly" action)
- next we decide, wether we create anomaly at location or at GM position (assume it's GM position)

Finally, we arrive at a parsed statement (here called Expression). 
It contains an array of expression members, which can be all be put one next to another to construct the text string for the statement.

Each time we edit something (any value within a statement), the process repeats. 
Say if we want to have a point, not GM position, we will set "use_gm_position" to null, 
which will make the check for GM position to decide it's not a GM position but a point
Or we can change the action type - and the expression will change dramatically.


What classes are used and how:

1. MissionStatement 
This class contains all the attributes and values that the XML element has.

2. Expression
The class that contains methods used to construct an Expression. An actual expression is stored as a List<ExpressionMemberContainer>

3. ExpressionMember (and ExpressionMemberCheck)
This is a building block of an Expression. An expression consists of ExpressionMembers stacked one after another. 
For example, in the above example, "anomaly" is an Expression member, as well as "at side" and "name" and so on.

An ExpressionMember can either be a "Check" or not.
- If not, it's somehow used as a building block in an expression (either just filler text, like "with name", or editable value, like "name")
- If it's a check, then it is not stored in XML, and sometimes not even displayed in the text representation of the statement, but rather used to branch.
In this case it's a ExpressionMemberCheck class which as a list of PossibleExpressions and a Decide method. 
PossibleExpressions contain the possible List<ExpressionMembers> that can branch from this check. 
For example, a check for point or GM position, there will be two entries, 
one for point (it will contain ExpressionMembers for "at point" "X," "Y," "Z") 
and one for GM (it will contain ExpressionMembers for "selected by GM" and an invisible member that sets the flag in xml).
Decide method makes the decision which of the possible expressions is used. It looks at whatever it needs to look at.
For example, in case of point or GM position check, it will look at wether the "selected_by_GM" value is set.

ExpressionMember class is used in the structure that defines the allowed mission xml syntax. It's not actually used to represent 
specific instances of the expression members - for that purpose, ExpressionMemberContainer class is used.

The way ExpressionMembers define the allowed mission syntax is as follows:

- Expression.Root contains the root ExpressionMember, of the ExpressionMemberCheck_XmlNode_H class. 
This class is a check responsible for deciding wether the expression is a commentary, action or condition. 
Therefore, it's PossibleExpressions (defined in the constructor) contain three lists of one check each - Commentary, Action and Condition checks.
It's Decide simply looks at what Type the statement has and thus decides wether it's a commentary or action.

- Every "main" check class for Action and Condition has a big list of PossibleExpressions. 
They are called ExpressionMemberCheck_XmlNameAction and  ExpressionMemberCheck_XmlNameCondition
The constructor of these two classes contains the bulk of the syntax logic. It branches most of the commands.

- Every additional branching is done through other classes that also inherit ExpressionMemberCheck. 
The constructor defines the exact ExpressionMembers added by the check, 
the Decide method defines how the check makes it's choice, 
while SetValueInternal defines how does the check enforce it's choice if it's a user-changeable.
For example, in case of "point or GM pos" choice, when the user choses "point", SetValueInternal will clear the "use_gm_position" variable,
while if the user choses "gm pos", then it will set that variable.

- Therefore, code in constructors, Decide and SetValueInternal method of all the ExpressionMember classes together defines the syntax 
and the parsing logic. 

4. ExpressionMemberContainer
This class represents the instance of an ExpressionMember found in a specific statement: it links ExpressionMember and MissionStatement together. 
This class has methods that send stuff through: when you, say, need to run Decide method of an ExpressionMemberCheck,
then ExpressionMemberContainer will call Decide method and pass MissionStatement to it, so that the Decide method knows where to look for the values,
whatever values they need. Same for other methods (like, SetValue) - ExpressionMember knows how to set the value, while Container supplies
the MissionStatement which holds the value to set.


How it all works (example):

1. MissionStatement.Update() is called. 
   This function, amongst other things, constructs the expression
2. Expressions.ConstructExpression() is called. 
   This function begins the recursive construction by calling the first Append with the Root ExpressionMember
3. Expressions.Append() is called for the first time. 
   This function appends the Root ExpressionMember to the statement. Since it is a check, it will decide what to add next 
4. ExpressionMemberCheck.Decide() is called on Root (class ExpressionMemberCheck_XmlNode_H).
   It decides wether the Statement is a Comment, Condition or Action. Depending on what it is, next check is added.
5. Expressions.Append() is called for the second time.
   This time, Comment, Condition or Action's main check is added. If it's not a comment, it will decide what kind of condition/action it is.
   Since this is Action, we add the action's main check.
6. ExpressionMemberCheck.Decide() is called on class ExpressionMemberCheck_XmlNameAction.
   It decides what to add next. It checks the element name, sees "create" and thus chooses ExpressionMemberCheck_CreateType_H
7. Expressions.Append() is called for the third time.
8. ExpressionMemberCheck.Decide() is called on class ExpressionMemberCheck_CreateType_H
   This time, we decide what kind of object is being added. Since it's anomaly, we add more than one ExpressionMember this time:
   - type (allowing us to choose a type of the object being created)
   - "at " (just a text string to make the whole statement easier to comprehend)
   - ExpressionMemberCheck_Point_x_GMPos (this is the Check that will either add "point" or "GM pos")
   - "with " (another string)
   - "name " (another string)
   - name (allowing us to edit name of the object)
9. Expressions.Append() is called for the fourth time (for the "type").
10. This time it's not a check so it just adds it and goes on to next on the list
11. Expressions.Append() is called (for the "at ")
12. Expressions.Append() is called (for the ExpressionMemberCheck_Point_x_GMPos)
    This time, decision will be made that again adds multiple ExpressionMembers. 
	They will be processed before we return to processing the next on our current list - "with ".
And so on...


Auxillary classes for the Expression:

1. ExpressionMemberValueType
This class describes the way mission editor treats the value. Basically it's either:
- Nothing, in which case this is not a value at all, but either a label, check or a derived value
- Body, which means the value is stored as a multi-line string in the element's body
- one of the typical Int/Double/Bool etc types

2. ExpressionMemberValueEditor
This class describes the way mission editor allows to edit the value. 
By default it will just show a popup dialog, but you can also specify a method that will prepare a dropdown menu.
This class also contains dictionaries to convert strings between display and xml. 
This way, for example, you can make "add_ai" display as "Add AI command"

3. ExpressionMemberValueDescription
This class describes the way value is treated. It combines the type, the editor, denotes what kind of text is added to the sides of the value,
for example, quotes, spaces, brackets or maybe a colon on the right, as well as setting boundaries for numeric variables. 
If you need to add a new value, like, capitain's type, you add an extra EMVD.
This class has a static dictionary for all the different EMVD's - most of the time, you use GetItem to get the EMVD you need.

